{"ast":null,"code":"var _jsxFileName = \"/app/src/components/d3component_testfield.js\";\nimport React, { useEffect, useRef, useState } from 'react';\nimport * as d3 from \"d3\";\nimport * as axios from \"axios\";\nexport default function D3Graph(props) {\n  const d3Container = useRef(null);\n  const [books, setBooks] = useState(initialBooks);\n  useEffect(() => {},\n  /*\n      useEffect has a dependency array (below). It's a list of dependency\n      variables for this useEffect block. The block will run after mount\n      and whenever any of these variables change. We still have to check\n      if the variables are valid, but we do not have to compare old props\n      to next props to decide whether to rerender.\n  */\n  [props.data, d3Container.current]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"d3-graph\",\n    ref: d3Container,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 19\n    }\n  });\n}","map":{"version":3,"sources":["/app/src/components/d3component_testfield.js"],"names":["React","useEffect","useRef","useState","d3","axios","D3Graph","props","d3Container","books","setBooks","initialBooks","data","current"],"mappings":";AAAA,OAAOA,KAAP,IAAeC,SAAf,EAA0BC,MAA1B,EAAkCC,QAAlC,QAAiD,OAAjD;AACA,OAAO,KAAKC,EAAZ,MAAoB,IAApB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AASA,eAAe,SAASC,OAAT,CAAiBC,KAAjB,EAAuB;AAElC,QAAMC,WAAW,GAAGN,MAAM,CAAC,IAAD,CAA1B;AAEA,QAAM,CAACO,KAAD,EAAQC,QAAR,IAAoBP,QAAQ,CAACQ,YAAD,CAAlC;AAEAV,EAAAA,SAAS,CACL,MAAM,CAEL,CAHI;AAKL;;;;;;;AAOA,GAACM,KAAK,CAACK,IAAP,EAAaJ,WAAW,CAACK,OAAzB,CAZK,CAAT;AAmBA,sBAAc;AACV,IAAA,SAAS,EAAC,UADA;AAGV,IAAA,GAAG,EAAEL,WAHK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAd;AAKH","sourcesContent":["import React, {useEffect, useRef, useState} from 'react';\nimport * as d3 from \"d3\";\nimport * as axios from \"axios\";\n\n\n\n\n\n\n\n\nexport default function D3Graph(props){\n\n    const d3Container = useRef(null);\n\n    const [books, setBooks] = useState(initialBooks)\n\n    useEffect(\n        () => {\n\n        },\n\n        /*\n            useEffect has a dependency array (below). It's a list of dependency\n            variables for this useEffect block. The block will run after mount\n            and whenever any of these variables change. We still have to check\n            if the variables are valid, but we do not have to compare old props\n            to next props to decide whether to rerender.\n        */\n        [props.data, d3Container.current])\n\n\n\n\n\n\n    return        <div\n        className=\"d3-graph\"\n\n        ref={d3Container}\n    />\n}\n\n"]},"metadata":{},"sourceType":"module"}